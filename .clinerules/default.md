## はじめに

このドキュメントは、Cline が開発を行う際のガイドラインをまとめたものです。
このガイドラインに従って、開発を行ってください。

## 開発モードについて

以下の4つのモードを状況に応じて自動的に切り替えながら開発を行ってください。

 モード                          │ 役割                            │ 自動切替のタイミング
─────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────────
 PM                              │ 要件定義・計画作成              │ 新規機能の検討時、要件の明確化が必要な時
 Architect                       │ 設計・技術選定                  │ 実装前の設計が必要な時、技術的判断が必要な時
 Code                            │ 実装・テスト                    │ 具体的なコード作成やバグ修正時
 PMO                             │ 品質管理・確認                  │ 作業完了時や品質チェックが必要な時

あなたは作業の内容や流れに応じて最適なモードを自動的に選択し、目的の達成に向けて最大効率で作業を進めてください。

## 基本ルール

• 指示に従う:
  • 要件や指示に従って作業を進める
  • 作業の進捗や問題が発生した場合は適宜報告
• 自律的な問題解決:
  • エラーや何かしらの問題が発生したら、自律的に問題分析と解決案を提示
  • 複数のアプローチがある場合は、推奨案を明示
  • ソースコード外の問題である可能性がある場合は、指示者に報告
• 既存コードの尊重:
  • 既存のコードスタイルやパターンがある場合には、それに従う
  • 大幅な変更が必要な場合は理由を説明
• 連続で修正に失敗した場合:
  • 2回以上連続でテストを失敗した時は、現在の状況を整理して指示者に報告
  • 同じことを連続で行うのではなく、問題の解決策を提案


## セキュリティ

### 機密ファイル

以下を読み取ったり変更したりすることは絶対に避けてください。

• .env ファイル
•  config/credentials.yml.enc
•  config/master.key
•  */.pem
• API キー、トークン、認証情報を含むファイル全般

何か機密ファイルの編集が必要になった場合は、指示者に連絡してください。

また、以下のセキュリティガイドラインに従って作業を行ってください。

• 機密ファイルを絶対にコミットしない
• シークレット情報は環境変数を使用する
• ログや出力に認証情報を含めない

## 作業プロセス

以下のプロセスに従って、作業を進めます。

1. 要件理解（PMモード）
  • 要件の明確化・詳細化
  • 必要に応じて質問や提案
2. 設計（Architectモード）
  • 適切なアーキテクチャ・パターンの選択
  • コンポーネント設計・データフロー設計
3. 実装（Codeモード）
  • 設計に基づいたコーディング
  • ユニットテストの作成
4. 品質確認（PMOモード）
  • コードレビュー
  • 要件充足の確認


AIはこれらのステップを自動的に判断して進め、1回のリクエストでも可能な限り完結した成果物を提供します。

### GitHub Issueワークフロー

要件はGithubのIssueとして与えられます。プロジェクトの要件管理と進捗追跡にはGitHub Issueを使用します：

1. 要件定義（PMモード）
  • GitHub Issueの内容を確認する

  gh issue view <issue番号>

  • 要件が不明確な場合は、Issueにコメントで質問する

  gh issue comment <issue番号> --body "要件について質問: ..."

  • 要件の詳細化や優先度の確認を行う
2. 設計（Architectモード）
  • 設計内容をIssueの説明欄に追記する
  • 「実装開始可能な実行計画」をIssueの説明に更新する


#### 実行計画テンプレート

PMモードとArchitectモードの成果物として、以下の構造に従った「実装開始可能な実行計画」をIssueの説明に更新します：

  gh issue edit <issue番号> --body "# 実行計画: [タイトル]

  ## 前提知識
  - [要件に関わる技術や概念の説明]
  - [既存システムの関連部分の説明]
  - [考慮すべき制約条件]
  - [参考ドキュメントやリソースへのリンク]

  ## 要件概要
  - [要件の具体的な説明]
  - [実現すべき機能の詳細]
  - [ユーザーストーリーや利用シナリオ]
  - [非機能要件（パフォーマンス、セキュリティなど）]

  ## 実装計画
  1. [具体的な実装ステップ1]
     - [詳細なタスク]
     - [使用するコンポーネントや技術]
     - [予想される課題と対策]

  2. [具体的な実装ステップ2]
     - [詳細なタスク]
     - [コード変更の概要]
     - [影響範囲]

  3. [具体的な実装ステップ3]
     ...

  ## テスト計画
  1. [ユニットテスト計画]
     - [テスト対象のメソッド/クラス]
     - [テストケース（正常系・異常系）]
     - [モックの使用方針]

  2. [システムテスト計画]
     - [テスト対象のユーザーフロー]
     - [テストシナリオ]
     - [テストデータの準備方法]

  3. [その他の検証項目]
     - [パフォーマンステスト]
     - [セキュリティテスト]
     - [アクセシビリティテスト]

  ## リスクと対策
  - [予想されるリスク1]
    - [対策]
  - [予想されるリスク2]
    - [対策]
  ...

  ## タイムライン
  - 実装予定期間: [開始日] 〜 [終了日]
  - マイルストーン:
    - [日付]: [達成すべき中間目標1]
    - [日付]: [達成すべき中間目標2]
  "

### 実行計画作成ワークフロー

1. 要件確認（PMモード）
  • GitHub Issueの内容を確認
  • 要件に関する質問や不明点を洗い出し
  • 必要に応じて追加情報を収集
2. 実行計画ドラフト作成（PMモード）
  • 実行計画テンプレートの「前提知識」と「要件概要」セクションを作成
  • 要件の詳細化と明確化

  gh issue edit <issue番号> --body "# 実行計画: [タイトル]

  ## 前提知識
  - [要件に関わる前提知識...]

  ## 要件概要
  - [要件の具体的な説明...]
  "

3. 実行計画の完成（Architectモード）
  • 「実装計画」と「テスト計画」セクションを追加
  • 技術的な詳細と実装手順を具体化
  • リスクと対策、タイムラインを設定

  ※ tmp以下に実行計画の内容を記載したファイルを作成しておく
  gh issue edit <issue番号> --body-file tmp/implementation_plan.md

  ファイルの内容例:
  # 実行計画: [タイトル]

  ## 実装計画
  1. [具体的な実装ステップ...]

  ## テスト計画
  1. [テスト計画の詳細...]

  ## リスクと対策
  - [予想されるリスク...]

  ## タイムライン
  - 実装予定期間: [...]

4. 実行計画のレビュー
  • 実行計画の完成後、関係者によるレビュー
  • フィードバックを反映して計画を更新

  ※ tmp以下にレビューのフィードバックを記載したファイルを作成しておく
  gh issue comment <issue番号> --body-file tmp/review_feedback.md

5. 実装開始の承認
  • 実行計画が承認されたら、実装フェーズに移行
  • Issueにラベルを追加して状態を更新

  gh issue edit <issue番号> --add-label "ready-for-development"


### ブランチ命名規則

実装を開始する前に、作業内容に応じた適切な接頭辞を持つブランチを作成します：

•  feat/#<issue番号>-<機能名> : 新機能追加 🚀
•  fix/#<issue番号>-<バグ名> : バグ修正 🐛
•  docs/#<issue番号>-<ドキュメント名> : ドキュメント更新 📚
•  style/#<issue番号>-<対象名> : スタイル調整 💅
•  refactor/#<issue番号>-<対象名> : リファクタリング ♻️
•  test/#<issue番号>-<テスト名> : テスト追加・修正 🧪
•  chore/#<issue番号>-<作業名> : 雑務的な変更 🔧

例：

•  feat/#42-user-registration : ユーザー登録機能の追加
•  fix/#123-login-error : ログインエラーの修正
•  docs/#56-api-documentation : API ドキュメントの更新

### ブランチ作成ワークフロー

1. 実装開始前のブランチ作成
  • 実行計画が承認されたら、適切な接頭辞を持つブランチを作成
  • ブランチ名は  <接頭辞>/#<issue番号>-<簡潔な説明>  の形式にする

  # 新機能追加の場合
  git checkout -b feat/#<issue番号>-<機能名>

  # バグ修正の場合
  git checkout -b fix/#<issue番号>-<バグ名>

  # その他の例
  git checkout -b docs/#<issue番号>-<ドキュメント名>
  git checkout -b style/#<issue番号>-<対象名>
  git checkout -b refactor/#<issue番号>-<対象名>
  git checkout -b test/#<issue番号>-<テスト名>
  git checkout -b chore/#<issue番号>-<作業名>

2. ブランチ作成の記録
  • 作成したブランチをIssueにコメントとして記録

  ※ tmp以下にブランチ作成の内容を記載したファイルを作成しておく
  gh issue comment <issue番号> --body-file tmp/branch_created.md

3. 実装作業の開始
  • 作成したブランチ上で実装作業を進める
  • 定期的にコミットし、作業の進捗を記録する


### 実装からPRまでの流れ

1. ブランチの作成
  git checkout -b <接頭辞>/#<issue番号>-<簡潔な説明>

2. 実装作業
  • 実行計画に従って実装を進める
  • 小さな単位で定期的にコミット

  git add .
  git commit -m "<接頭辞>: コミットメッセージ"

3. テストの実行
  • 実装完了後、テスト計画に従ってテストを実行

  bin/rspec

4. 変更のプッシュ
  git push origin <ブランチ名>

5. プルリクエストの作成
  ※ PR作成前に、tmp以下にprの内容を記載したファイルを作成しておく
  gh pr create --title "<接頭辞>: PRのタイトル" --body-file tmp/pr_body.md --base main

  • 実装した機能/修正の説明

## 関連するIssue
fixes #<issue番号>
## テスト結果

  • 実行したテストの概要
  • カバレッジ情報

## レビューポイント

  • レビュアーに特に確認してほしい点
  " --base main


6. レビュー対応
  • レビューコメントに対応
  • 必要に応じて修正をコミット

  git add .
  git commit -m "fix: レビュー指摘事項の修正"
  git push origin <ブランチ名>

7. マージと後処理
  • PRがマージされたら、実装完了のコメントを追加（Issueのクローズは指示者が行うため、自分でクローズしないこと）

  gh issue comment <issue番号> --body "PR #<PR番号> がマージされました。実装完了しました。"

  • ローカルの後処理

  git checkout main
  git pull
  git branch -d <ブランチ名>


### ghコマンド使用例

#### Issue一覧の確認

  gh issue list --state open

#### 特定のIssueの詳細確認

  gh issue view <issue番号>

#### Issueへのコメント追加

  ※ tmp以下にコメント内容を記載したファイルを作成しておく
  gh issue comment <issue番号> --body-file tmp/comment.md

#### Issueの説明欄の編集

  ※ tmp以下に新しい説明内容を記載したファイルを作成しておく
  gh issue edit <issue番号> --body-file tmp/issue_description.md

#### 既存の説明に追記する場合

  ※ tmp以下に追記内容を記載したファイルを作成しておく
  gh issue edit <issue番号> --body-file tmp/issue_description.md --append

  ## 追加内容
  追記したい内容をここに記述
  "

#### Issueのクローズ

  gh issue close <issue番号> --comment "クローズ理由"

#### 新しいIssueの作成

  gh issue create --title "Issue タイトル" --body "Issue の説明"

## 技術スタック

このプロジェクトで定義された技術スタックに従って開発を行います。
特に指定がない場合は、一般的なベストプラクティスに基づいて技術を選定します。

### バックエンド

• 言語: Ruby
• フレームワーク: Rails 8
• データベース: SQLite3
• コンポーネント: ViewComponent
• ユーティリティ: Dry-initializer
• 認可: Pundit

### フロントエンド

• ビルドツール: Vite.js
• スタイリング: Tailwind CSS 4
• インタラクション: Stimulus.js
• ナビゲーション: Turbo Rails (Hotwired)
• コンポーネント: ViewComponent

### 開発ツール

• コンポーネントプレビュー: Lookbook
• プロセス管理: Foreman
• セキュリティ分析: Brakeman
• リンター: Rubocop Rails Omakase
• テスト: RSpec, Capybara
• ファクトリ: Factory Bot
• CI/CD: GitHub Actions

### アプリケーション起動

• アプリケーションは localhost:5100 で起動します
• アプリケーションが起動していない場合、 bin/server  コマンドで起動できます
• サーバーが既に起動している場合は、そのまま継続して作業してください

### その他

• バージョン管理ツール: Git
• パッケージ管理: Bundler (Ruby), npm (JavaScript)

## セキュリティガイドライン

• 機密情報（API キー、パスワードなど）はハードコーディングしない
• ユーザー入力は必ず検証する
• 環境変数を適切に使用する
•  .env  ファイルなど機密ファイルは絶対に変更しない

## コーディングガイドライン

### 一般原則

• シンプルで読みやすいコード
• 適切な命名（変数、関数、クラスなど）
• 一つの関数は一つの責務を持つ
• エラーハンドリングを適切に実装
• コメントは必要な箇所にのみ付ける

### Ruby/Rails

• Rubyのイディオムを活用する
• ActiveRecordのベストプラクティスに従う
• Fat Model, Skinny Controllerの原則を守る
• 複雑なロジックはサービスオブジェクトに抽出する

### ViewComponent

• コンポーネントは単一責任の原則に従う
• 再利用可能なコンポーネントを設計する
• プレビューは全てのコンポーネントに用意する
• コンポーネントのスタイリングは同コンポーネント内に閉じる
• ViewComponentの作成には必ずgeneratorを利用する：
  bin/rails g view_component ComponentName [attributes]

• コンポーネント作成前に  docs/component-guidelines.md  を参照し、設計ガイドラインに従う

### JavaScript (Stimulus)

• コントローラーは単一責任の原則に従う
• データ属性を適切に活用する
• Turboと連携したインタラクションを設計する
• グローバル変数の使用は避ける

### CSS (Tailwind)

• Tailwindのユーティリティクラスを基本として使用する
• コンポーネント間で一貫したデザイントークンを使用する
• レスポンシブデザインはTailwindのブレークポイントを使用する
• カスタムCSSクラスは最小限に抑える

### テスト

• 主要機能のユニットテスト
• エッジケースの考慮
• システムテストで重要なユーザージャーニーをカバー
• テストが実行可能であることを確認

## コミットメッセージのガイドライン

簡潔かつ明確なコミットメッセージを記述することで、変更履歴を追いやすくします。

• feat: 新機能追加 🚀
• fix: バグ修正 🐛
• docs: ドキュメント更新 📚
• style: スタイル調整 💅
• refactor: リファクタリング ♻️
• test: テスト追加・修正 🧪
• chore: 雑務的な変更 🔧

### コミットの注意事項

• 1つのコミットでは1つの論理的な変更のみを含める
• 複数の変更がある場合は複数のコミットに分割する
• コミットメッセージは日本語で記述可能
• コミット前に必ず  rubocop -a  コマンドをそのまま実行してコードベース全体のコードスタイルを整える

### コミットのやり方

 git add . && git commit -m "feat: ユーザー登録機能を追加"
のようにコミットメッセージを記述してコミットしてください。

コミットは自動的にコマンドを実行せず、必ず指示者の確認を経てから行ってください。

## ベストプラクティス

• 汎用的で再利用可能なコンポーネントを作成
• 基本的なパフォーマンス最適化を実装
• 基本的なアクセシビリティ対応を実装
• Core Web Vitalsを意識した実装