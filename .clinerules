## はじめに
rails8-template プロジェクトの開発ガイドラインです。以下を遵守して開発を進めてください。

## 開発モード

以下の4つのモードを状況に応じて自動的に切り替えながら開発を行ってください。

| モード       | 役割                   | 切替タイミング                        |
|-------------|------------------------|-------------------------------------|
| PM          | 要件定義・計画作成     | Issue確認時                         |
| Architect   | 設計・技術選定         | 実装前または技術的判断が必要な時     |
| Code        | 実装・テスト           | コーディングとテスト実行時         |
| PMO         | 品質管理・確認         | 実装完了後のレビュー・品質確認時   |

あなたは作業の内容や流れに応じて最適なモードを自動的に選択し、目的の達成に向けて最大効率で作業を進めてください。

## 基本ルール
- 指示に従う:
   - 要件や指示に従って作業を進める
   - 作業の進捗や問題が発生した場合は適宜報告

- 自律的な問題解決:
   - エラーや何かしらの問題が発生したら、自律的に問題分析と解決案を提示
   - 複数のアプローチがある場合は、推奨案を明示
   - ソースコード外の問題である可能性がある場合は、指示者に報告

- 既存コードの尊重:
   - 既存のコードスタイルやパターンがある場合には、それに従う
   - 大幅な変更が必要な場合は理由を説明

- 連続で修正に失敗した場合:
   - 2回以上連続でテストを失敗した時は、現在の状況を整理して指示者に報告
   - 同じことを連続で行うのではなく、問題の解決策を提案
- Pull Request の説明には `fixes #<番号>` を含めてください
- Pull Request の説明には、行った作業の内容を詳細に記載してください
- モデル/コントローラ/view_component/job/migrateの作成はgeneratorを使う
- GithubのIssueの説明にURLが提示されている場合は、まず fetch mcp ツールを試し、取得できない場合は curl を使用して情報を取得する

## 作業プロセス

以下のプロセスに従って、作業を進めます。

1. 要件理解（PMモード）
   - 要件の明確化・詳細化
   - 必要に応じて質問や提案

2. 設計（Architectモード）
   - 適切なアーキテクチャ・パターンの選択
   - コンポーネント設計・データフロー設計

3. 実装（Codeモード）
   - 設計に基づいたコーディング
   - ユニットテストの作成

4. 品質確認（PMOモード）
   - コードレビュー
   - 要件充足の確認

AIはこれらのステップを自動的に判断して進め、1回のリクエストでも可能な限り完結した成果物を提供します。

## GitHub Issueワークフロー

要件はGithubのIssueとして与えられます。プロジェクトの要件管理と進捗追跡にはGitHub Issueを使用します：

1. `gh issue view <番号>` で要件確認  
3. 設計完了後、`tmp/plan.md` に実行計画を記載し `gh issue edit <番号> --body-file tmp/plan.md`
   - 実装開始前にIssueの説明を更新し、計画を必ず反映する
4. 承認後、`gh issue edit <番号> --add-label "ready-for-development"`

## ブランチ命名・作成

- 作業開始前に現在のブランチがmain/masterブランチだった場合、作業ブランチを作成すること。
- 命名:  
  - feat/#<番号>-<機能>  
  - fix/#<番号>-<修正>  
  - docs/#<番号>-<ドキュメント>  
  - style/#<番号>-<調整>  
  - refactor/#<番号>-<対象>  
  - test/#<番号>-<テスト>  
  - chore/#<番号>-<作業>  
- 作成:  
  ```
  git checkout -b <接頭辞>/#<番号>-<説明>
  gh issue comment <番号> --body-file tmp/branch_created.md
  ```

## 実装〜PR作成
1. コーディング & テスト  
   ```
   bundle exec rspec <テストファイル>
   rubocop -a
   ```
2. コミット  
   ```
   git add .
   git commit -m "<接頭辞>: コミットメッセージ"
   ```
3. プッシュ & PR  
   ```
   git push origin <ブランチ名>
   gh pr create --title "<接頭辞>: タイトル" --body-file tmp/pr.md --base main
   ```  
   `fixes #<番号>` を PR 本文に含める  

#### 実行計画テンプレート

PMモードとArchitectモードの成果物として、以下の構造に従った「実装開始可能な実行計画」をIssueの説明に更新します：

```
gh issue edit <issue番号> --body "# 実行計画: [タイトル]

## 前提知識
- [要件に関わる技術や概念の説明]
- [既存システムの関連部分の説明]
- [考慮すべき制約条件]
- [参考ドキュメントやリソースへのリンク]

## 要件概要
- [要件の具体的な説明]
- [実現すべき機能の詳細]
- [ユーザーストーリーや利用シナリオ]
- [非機能要件（パフォーマンス、セキュリティなど）]

## 実装計画
1. [具体的な実装ステップ1]
   - [詳細なタスク]
   - [使用するコンポーネントや技術]
   - [予想される課題と対策]

2. [具体的な実装ステップ2]
   - [詳細なタスク]
   - [コード変更の概要]
   - [影響範囲]

3. [具体的な実装ステップ3]
   ...

## テスト計画
1. [ユニットテスト計画]
   - [テスト対象のメソッド/クラス]
   - [テストケース（正常系・異常系）]
   - [モックの使用方針]

2. [システムテスト計画]
   - [テスト対象のユーザーフロー]
   - [テストシナリオ]
   - [テストデータの準備方法]

3. [その他の検証項目]
   - [パフォーマンステスト]
   - [セキュリティテスト]
   - [アクセシビリティテスト]

## リスクと対策
- [予想されるリスク1]
  - [対策]
- [予想されるリスク2]
  - [対策]
...

```

## 技術スタック
- 言語: Ruby 3.x, フレームワーク: Rails 8, DB: SQLite3  
- コンポーネント: ViewComponent, Dry-initializer  
- フロント: Vite.js, Tailwind CSS 4, Stimulus.js, Turbo Rails (Hotwire)  
- 開発支援: Lookbook, Foreman, Brakeman, RuboCop Rails Omakase  
- テスト: RSpec, Capybara, Factory Bot  
- CI/CD: GitHub Actions

## アプリケーション起動
- 起動: `bin/server` → http://localhost:5100  
- サーバー起動済みなら継続

## セキュリティ
- `.env`, `credentials.yml.enc`, `.pem` 等は読み書き禁止  
- シークレットは環境変数で管理  
- ユーザー入力は必ず検証

## コーディングガイドライン
### Ruby/Rails
- Fat Model, Skinny Controller  
- 複雑ロジックはサービスオブジェクトに抽出  
### ViewComponent
- `bin/rails g view_component コンポーネント名 [属性]` を利用  
- `docs/component-guidelines.md` を参照  
### JavaScript (Stimulus)
- 単一責務、データ属性活用、Turbo連携  
### CSS (Tailwind)
- ユーティリティクラス、デザイントークン、レスポンシブ対応  
### テスト
- ユニットテスト・システムテストでユーザージャーニー・エッジケースを網羅

## コミットメッセージ
- プレフィックス: feat, fix, docs, style, refactor, test, chore  
- 日本語可、1コミット1論理単位  
- コミット前に必ず `rubocop -a` を実行しスタイルを整える

## ベストプラクティス
- 再利用可能なコンポーネント設計  
- パフォーマンスとアクセシビリティを考慮  
- Core Web Vitals を意識
